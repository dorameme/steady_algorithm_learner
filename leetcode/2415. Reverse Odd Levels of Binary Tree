ë¬¸ì œ- ê° í™€ìˆ˜ì¸µì—ìˆëŠ” ë…¸ë“œë“¤ì˜ ìˆœì„œë¥¼ ê±°ê¾¸ë¡œ ë’¤ë°”ê¾¸ì–´ë¼.
-> level-order travalsal(BFS) ì•Œê³ ë¦¬ì¦˜ì‚¬ìš© í˜¹ì€ dfs ì‚¬ìš©

Q. Given the root of a perfect binary tree, reverse the node values at each odd level of the tree.

A. dfs
class Solution {
private:
    void reverse(TreeNode* rootL, TreeNode* rootR, int level) {
        if(rootL == NULL and rootR == NULL) return; //ê°’ì´ ë”ì´ìƒ ì—†ìœ¼ë©´ ë¦¬í„´
        if(level % 2 == 0) swap(rootL->val, rootR->val);//ì¸µì´ í™€ìˆ˜ë©´ ê° ê°’ì„ ê±°ê¾¸ë¡œ ë°”ê¿”ì¤€ë‹¤.
        reverse(rootL->left, rootR->right, level + 1);//ì™¼ìª½ì˜ ì™¼ìª½  ì˜¤ë¥¸ìª½ì˜ ì˜¤ë¥¸ìª½
        reverse(rootL->right, rootR->left, level + 1);//ì™¼ìª½ì˜ ì˜¤ë¥¸ìª½ ì˜¤ë¥¸ìª½ì˜ ì™¼ì¡±
    }
public:
    TreeNode* reverseOddLevels(TreeNode* root) {
        reverse(root->left, root->right, 0);
        return root;
    }
};

A>level-order travalsal
íŠ¸ë¦¬ì˜ ë ˆë²¨ ìˆœì„œëŒ€ë¡œ ìˆœíšŒí•˜ëŠ” Level order traversal
íë¥¼ ì´ìš©
1) ë£¨íŠ¸ ë…¸ë“œë¥¼ ë°©ë¬¸í•œë‹¤.
2) ë£¨íŠ¸ ë…¸ë“œì˜ Left Child ë¥¼ ë°©ë¬¸í•œë‹¤.
3) ë£¨íŠ¸ ë…¸ë“œì˜ Right Childë¥¼ ë°©ë¬¸í•œë‹¤.


class Solution {
public:
    TreeNode* reverseOddLevels(TreeNode* root) {
        queue<TreeNode*> q; 
        //Insert the root node which is at level=0 in the queue
        q.push(root); ///ë£¨íŠ¸ë¥¼ ë„£ì–´ì¤€ë‹¤
        int level=0; 
        while (!q.empty()) {////íê°€ ë¹Œë•Œê¹Œì§€
            vector<int> nums; 
            int n=q.size();//íì˜ì‚¬ì´ì¦ˆ
            vector<TreeNode*> nodes; ///ì£¼ì†Œê°’ ì €ì¥!!ğŸ˜
            //Nodes will hold all the nodes of current level
            //Nums will hold their values 
            
            
            for (int i=0; i < n; i++){//íì‚¬ì´ì¦ˆë§Œí¼ ë°˜ë³µ
                TreeNode* curr= q.front();//íì•ì—ì„œ ëº´ì¤€ë‹¤ 
                q.pop();
                nums.push_back(curr->val); //í˜„ì¬ ê°’ì„ ë²¡í„°ì— ì €ì¥
                nodes.push_back(curr); //ë…¸ë“œì˜ ê°’ì„ ì €ì¥
                if(curr->left) q.push(curr->left); //í˜„ì¬ íì˜ ì™¼ìª½ì„ íì—ë„£ëŠ”ë‹¤
                if(curr->right) q.push(curr->right); //í˜„ì¬ íì˜ ì˜¤ë¥¸ìª½ì„ íì—ë„£ëŠ”ë‹¤.
                
            }
            //If the level is odd, I will reverse the values and assign them to the TreeNodes using a for loop. 
            if(level%2){//ë§Œì¼ í™€ìˆ˜ì¸µì´ë©´
                reverse(nums.begin(), nums.end());//ë²¡í„°ìˆëŠ” ëª¨ë“ ê°’ì„ ë¦¬ë²ŒìŠ¤ 
                for (int i=0; i< nodes.size(); i++) {
                    TreeNode* curr= nodes[i]; //ì£¼ì†Œë¥¼ í˜„ì¬ ë…¸ë“œë¥¼ ë„£ìŒ
                    curr->val= nums[i]; //ì£¼ì†Œê°’ì˜ í˜„ì¬ì— ë²¡í„°ì— ë¦¬ë²ŒìŠ¤ëœ ê°’ë“¤ì„ ì €ì¥
                }
            }
            //increase the level
            level++;
            
        }
        
        return root;
    }
};
